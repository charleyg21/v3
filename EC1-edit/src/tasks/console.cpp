/**
 * @file
 *
 * Task for handling communication between FreeRTOS-CLI and serial port.
 */

#include <cstdint>
#include <cstring>

#include "FreeRTOS.h"
#include "FreeRTOS_CLI.h"
#include "task.h"

#include "cmsis_os.h"

#include "main.h"

#include "console/commands.hpp"
#include "helpers/cmsis_os.hpp"

/// Maximum allowable CLI output string length.
#define MAX_OUTPUT_LENGTH 512

/// CLI output string buffer.
static char OUTPUT_STRING[MAX_OUTPUT_LENGTH];

/// Maximum allowable CLI input string length.
#define MAX_INPUT_LENGTH 512

/// CLI input string buffer.
static char INPUT_STRING[MAX_INPUT_LENGTH];

/// Warm welcome message to write on startup.
static const char WELCOME[]
    = ("Free RTOS command server.\r\n"
       "Type 'help' to view a list of registered commands.\r\n");

namespace {

#define FOR_ALL_THREAD_FLAGS(FUNC)                                                     \
    FUNC(UART_RECEIVE_COMPLETE)                                                        \
    FUNC(UART_TRANSMIT_COMPLETE)                                                       \
    FUNC(UART_ERROR)

enum class ThreadFlag : uint32_t {
#define DECLARE_ENUM(FLAG) FLAG,
    FOR_ALL_THREAD_FLAGS(DECLARE_ENUM) UNKNOWN
#undef DECLARE_ENUM
};

constexpr auto FLAGS = {
#define DECLARE_ENUM(FLAG) ThreadFlag::FLAG,
    FOR_ALL_THREAD_FLAGS(DECLARE_ENUM)
#undef DECLARE_ENUM
};

class Thread : public cmsis_os::Thread, public cmsis_os::Flaggable<Thread, ThreadFlag> {
public:
    Thread(void)
        : cmsis_os::Thread()
        , cmsis_os::Flaggable<Thread, ThreadFlag>(FLAGS)
    {
    }

    void target(UART_HandleTypeDef* huart);

private:
} THREAD;

}

void Thread::target(UART_HandleTypeDef* huart)
{
    console::commands::register_all();

    // Register callbacks.
    huart->RxCpltCallback = [](struct __UART_HandleTypeDef* huart) {
        THREAD.set_flag(ThreadFlag::UART_RECEIVE_COMPLETE);
    };

    huart->TxCpltCallback = [](struct __UART_HandleTypeDef* huart) {
        THREAD.set_flag(ThreadFlag::UART_TRANSMIT_COMPLETE);
    };

    huart->ErrorCallback = [](struct __UART_HandleTypeDef* huart) {
        THREAD.set_flag(ThreadFlag::UART_ERROR);
    };

    /**
     * Transmit a string of given size to the UART.
     */
    auto uart_puts = [huart](const char* string) {
        auto buffer = reinterpret_cast<uint8_t*>(const_cast<char*>(string));
        const uint16_t size = strlen(string);
        HAL_UART_Transmit_DMA(huart, buffer, size);
        _wait_flag(ThreadFlag::UART_TRANSMIT_COMPLETE, osWaitForever);
    };

    /**
     * Receive a single character from the UART.
     */
    auto uart_getch = [huart](void) {
        char ch = '\0';
        auto buffer = reinterpret_cast<uint8_t*>(&ch);
        const uint16_t size = sizeof(ch);
        HAL_UART_Receive_IT(huart, buffer, size);
        _wait_flag(ThreadFlag::UART_RECEIVE_COMPLETE, osWaitForever);
        return ch;
    };

    // Send a welcome message to the user.
    uart_puts(WELCOME);
    uint16_t input_index = 0;

    for (;;) {
        // Wait in a blocked state until a character is received.
        char received_char = uart_getch();

        if (received_char == '\n') {
            // The command interpreter is called repeatedly until it returns pdFALSE.
            BaseType_t moreDataToFollow;
            do {
                // Send the command string to the command interpreter.
                moreDataToFollow = FreeRTOS_CLIProcessCommand(
                    INPUT_STRING, OUTPUT_STRING, MAX_OUTPUT_LENGTH);

                // Write the output generated by the command interpreter to the console.
                uart_puts(OUTPUT_STRING);
            } while (moreDataToFollow != pdFALSE);

            // Clear the input string ready to receive the next command.
            input_index = 0;
            memset(INPUT_STRING, 0x00, MAX_INPUT_LENGTH);
        } else {
            // The if() clause performs the processing after a newline character
            // is received. This else clause performs the processing if any other
            // character is received.
            if (received_char == '\r') {
                // Ignore carriage returns.
            } else if (received_char == '\b') {
                // Backspace was pressed. Erase the last character in the input buffer.
                if (input_index > 0) {
                    input_index--;
                    INPUT_STRING[input_index] = '\0';
                }
            } else {
                // A character was entered. It was not a new line, backspace
                // or carriage return, so it is accepted as part of the input and
                // placed into the input buffer. When a '\n' is entered the complete
                // string will be passed to the command interpreter.
                if (input_index < MAX_INPUT_LENGTH) {
                    INPUT_STRING[input_index] = received_char;
                    input_index++;
                }
            }
        }
    }
}

extern "C" void init_console_task_globals(osThreadId_t handle)
{
    THREAD.set_handle(handle);
}

/**
 * Run the command console task.
 */
extern "C" void start_console_task(void* parameters)
{
    auto params_array = static_cast<void**>(parameters);
    auto huart = static_cast<UART_HandleTypeDef*>(params_array[0]);
    THREAD.target(huart);
}
